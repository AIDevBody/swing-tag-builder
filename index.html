<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swing Event Tags Selector</title>
  <!--
    This page dynamically loads tag categories from a publicly published
    Google Sheet.  Each category is defined by a GID (grid ID) in
    the `tagCategories` object below.  Tags are translated via
    language-specific columns such as `display_en`, `display_de`, etc.
    The available languages are determined by the intersection of
    languages present across all category sheets.  If the visitor's
    browser language is supported, it is selected automatically.
    Visitors can select tags from each category, copy the resulting
    tag string to their clipboard or start a new Google Calendar
    event with the tags appended to the description.
  -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-oHDEc8XedO9HRhcB1mxEiEqVJ29cNdV0U5KVKHGxIEw45vQ9rL79K19s+n7J5cizBqRjv0dso/veV8H/AqV+rA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 1rem;
      max-width: 960px;
    }
    h1 {
      text-align: center;
    }
    .category {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ccc;
    }
    .category-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .tag-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .controls {
      margin-top: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    textarea {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      padding: 0.5rem;
      font-size: 1rem;
    }
    button, select, a.calendar-link {
      padding: 0.5rem 1rem;
      font-size: 1rem;
    }
    .calendar-link {
      display: inline-block;
      text-decoration: none;
      color: #fff;
      background-color: #4285f4;
      border-radius: 4px;
    }
  </style>
  <!-- Include PapaParse via CDN for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js" integrity="sha512-4pVTTDP/EpYqxx2jXLNqybBlw7vSjnUj2In8D7EJqxLFHfvM9b6bZw3Aw3m6Hpd9DDTsLVljJ9gvgrqMwr0kBg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <h1>Swing Event Tag Selector</h1>
  <noscript>
    <p>JavaScript is required to use this page.</p>
  </noscript>
  <!-- Language selector placeholder -->
  <div id="language-container" style="margin-bottom: 1rem;"></div>
  <!-- Container for all categories -->
  <div id="categories"></div>
  <!-- Controls for output and actions -->
  <div class="controls">
    <label for="tag-output">Selected tags:</label>
    <textarea id="tag-output" readonly></textarea>
    <button id="copy-btn">Copy to clipboard</button>
    <!-- The calendar link will be updated dynamically -->
    <a id="calendar-link" class="calendar-link" href="#" target="_blank">Add to Google Calendar</a>
  </div>
  <!-- Debug log output.  When DEBUG is true, this area will
       display logs for troubleshooting.  The user may set
       DEBUG=false before publishing to hide this. -->
  <pre id="debug-log" style="display:none; white-space:pre-wrap; background:#f7f7f7; border:1px solid #ccc; padding:0.5rem; margin-top:1rem; max-height:200px; overflow:auto;"></pre>
  <script>
    // Set this flag to false before pushing to production to hide debug logs.
    const DEBUG = true;

    // Array to collect debug messages.  Logs will be appended here
    // when DEBUG is true and displayed in the #debug-log element.
    const debugLogs = [];

    function log(...args) {
      if (!DEBUG) return;
      // Convert objects to JSON strings; join into a single line
      const message = args.map(a => {
        if (typeof a === 'object') {
          try {
            return JSON.stringify(a);
          } catch (e) {
            return String(a);
          }
        }
        return String(a);
      }).join(' ');
      debugLogs.push(message);
      console.log(...args);
      updateDebugLog();
    }

    function updateDebugLog() {
      if (!DEBUG) return;
      const el = document.getElementById('debug-log');
      if (el) {
        el.textContent = debugLogs.join('\n');
      }
    }
    // Mapping of tag categories to their respective grid IDs
    const tagCategories = {
      location:        '1613110947',
      dance_type:      '1262810551',
      event_type:      '1767805000',
      level:           '21940718',
      role:            '580185679',
      music_speed:     '749180173',
      music_source:    '1438046882',
      language:        '1955960245',
      venue_type:      '1295506722',
      registration:    '2021528078',
      price_type:      '1041725092',
      age_policy:      '1166459861',
      footwear:        '1367263539'
    };

    // UI type definitions for each category.  These values
    // correspond to the "Swing‑Tags‑UI" sheet provided by the
    // user.  If new categories are added or UI types change in
    // that sheet, update this mapping accordingly.  Valid types:
    //  - 'checkbox-multi' : multiple selections via checkboxes
    //  - 'dropdown-single': single selection via a <select> element
    const uiTypes = {
      location:      'dropdown-single',
      dance_type:    'checkbox-multi',
      event_type:    'checkbox-multi',
      level:         'dropdown-single',
      role:          'checkbox-multi',
      music_speed:   'checkbox-multi',
      music_source:  'dropdown-single',
      language:      'dropdown-single',
      venue_type:    'dropdown-single',
      registration:  'dropdown-single',
      price_type:    'dropdown-single',
      age_policy:    'dropdown-single',
      footwear:      'checkbox-multi'
    };

    // Track the selected tag (if any) per category.  For
    // checkbox-multi categories this is unused, but for
    // dropdown-single categories it allows us to remove the previous
    // selection when a new one is chosen.
    const selectedPerCategory = {};

    // Base URL for the published CSV.  Each call substitutes the GID.
    const sheetBaseURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRExGpjR2tcEK9n9jgca0Vug94etEFuouriCIKCrh6T0ez7XOMHlOvKgpyQIf5aqXuFMLCgoA-vhee6/pub?gid=GID&single=true&output=csv';

    // When fetching Google Sheets CSVs, browsers block cross-origin requests due to
    // CORS.  To work around this, enable USE_CORS_PROXY to prepend a proxy URL
    // (like corsproxy.io) which forwards the request and adds the necessary
    // CORS headers.  If you self-host a proxy or do not need this workaround,
    // set USE_CORS_PROXY to false.  PROXY_BASE should include the trailing
    // slash and query prefix.  See https://nordicapis.com/10-free-to-use-cors-proxies/ for details.
    const USE_CORS_PROXY = true;
    const PROXY_BASE = 'https://corsproxy.io/?';

    // Optional: Load data from local files (in the same repository) instead of
    // remote Google Sheets.  This is useful when a GitHub Action fetches the
    // latest CSV files and commits them into a `data/` directory, which
    // eliminates CORS issues entirely.  If USE_LOCAL_DATA is true, the page
    // will fetch data from `${LOCAL_DATA_PATH}/${category}.csv`.  Set to
    // false to fetch from Google Sheets via the base URL and proxy.
    const USE_LOCAL_DATA = true;
    const LOCAL_DATA_PATH = 'data';

    // Storage for loaded data per category
    const categoryData = {};
    let availableLanguages = [];
    let selectedLanguage = 'en';
    let selectedTags = new Set();

    /**
     * Fetch and parse a CSV for a given category.
     * Returns an array of objects representing rows.
     */
    async function loadCategoryData(category, gid) {
      /**
       * Attempt to load a CSV for a given category from a local file, and
       * if that fails (e.g., because the file doesn't exist yet), fall back
       * to downloading it directly from Google Sheets via the configured
       * CORS proxy.  This allows the page to work even before the
       * GitHub Action has populated the `data/` directory.
       */
      // Build local and remote URLs.  Local files live in the repository
      // under LOCAL_DATA_PATH; remote files come from Google Sheets.
      const localUrl = `${LOCAL_DATA_PATH}/${category}.csv`;
      let remoteUrl = sheetBaseURL.replace('GID', gid);
      if (USE_CORS_PROXY) {
        remoteUrl = PROXY_BASE + encodeURIComponent(remoteUrl);
      }
      // Helper to fetch and parse a CSV given a URL.
      const fetchCsv = async (url) => {
        log('Fetching category', category, 'from', url);
        const resp = await fetch(url);
        if (!resp.ok) {
          log('Failed to fetch', category, resp.status, resp.statusText);
          return null;
        }
        const text = await resp.text();
        const parsed = Papa.parse(text.trim(), { header: true });
        log('Parsed', category, 'rows:', parsed.data.length);
        return parsed.data;
      };
      // Try local fetch first if enabled.
      if (USE_LOCAL_DATA) {
        try {
          const data = await fetchCsv(localUrl);
          if (data && data.length > 0) return data;
        } catch (err) {
          log('Local fetch error for', category, err);
        }
      }
      // Fallback: fetch from remote (Google Sheets).  If remote fetch also
      // fails, return an empty array so the UI can display an error.
      try {
        const data = await fetchCsv(remoteUrl);
        return data || [];
      } catch (err) {
        log('Remote fetch error for', category, err);
        return [];
      }
    }

    /**
     * Determine the languages present in a sheet by inspecting column names starting with "display_".
     */
    function extractLanguages(row) {
      return Object.keys(row)
        .filter(key => key.startsWith('display_'))
        .map(key => key.substring('display_'.length));
    }

    /**
     * Intersect multiple arrays.
     */
    function intersectLanguages(lists) {
      if (lists.length === 0) return [];
      return lists.reduce((acc, arr) => acc.filter(x => arr.includes(x)));
    }

    /**
     * Build the language selector dropdown and attach change handler.
     */
    function buildLanguageSelector() {
      const container = document.getElementById('language-container');
      if (availableLanguages.length === 0) {
        container.innerHTML = '';
        return;
      }
      const label = document.createElement('label');
      label.setAttribute('for', 'language-select');
      label.textContent = 'Language: ';
      const select = document.createElement('select');
      select.id = 'language-select';
      availableLanguages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang;
        option.textContent = lang;
        if (lang === selectedLanguage) option.selected = true;
        select.appendChild(option);
      });
      select.addEventListener('change', (e) => {
        selectedLanguage = e.target.value;
        refreshCategoryLabels();
        updateOutput();
      });
      container.innerHTML = '';
      container.appendChild(label);
      container.appendChild(select);
    }

    /**
     * Refresh the labels of all tag checkboxes when language changes.
     */
    function refreshCategoryLabels() {
      for (const category of Object.keys(tagCategories)) {
        const rows = categoryData[category] || [];
        const uiType = uiTypes[category] || 'checkbox-multi';
        if (uiType === 'checkbox-multi') {
          const list = document.getElementById(`list-${category}`);
          if (!list) continue;
          const labels = list.querySelectorAll('label');
          labels.forEach((labelEl) => {
            const tag = labelEl.getAttribute('data-tag');
            const row = rows.find(r => r.tag === tag);
            const translationKey = `display_${selectedLanguage}`;
            let text = '';
            if (row && row[translationKey] && row[translationKey].trim()) {
              text = row[translationKey];
            } else if (row && row.display_en && row.display_en.trim()) {
              text = row.display_en;
            } else {
              text = tag;
            }
            labelEl.textContent = text;
          });
        } else if (uiType === 'dropdown-single') {
          const selectEl = document.getElementById(`select-${category}`);
          if (!selectEl) continue;
          rows.forEach(row => {
            const activeValue = String(row['is-active'] || row['is_active']).toLowerCase();
            if (activeValue !== 'true') return;
            const tag = row.tag;
            const optionEl = selectEl.querySelector(`option[value="${tag}"]`);
            if (optionEl) {
              const translationKey = `display_${selectedLanguage}`;
              let text = '';
              if (row[translationKey] && row[translationKey].trim()) {
                text = row[translationKey];
              } else if (row.display_en && row.display_en.trim()) {
                text = row.display_en;
              } else {
                text = tag;
              }
              optionEl.textContent = text;
            }
          });
        }
      }
    }

    /**
     * Build the category sections with checkboxes.
     */
    function buildCategoryUI() {
      const container = document.getElementById('categories');
      container.innerHTML = '';
      for (const [category, rows] of Object.entries(categoryData)) {
        const uiType = uiTypes[category] || 'checkbox-multi';
        const section = document.createElement('div');
        section.classList.add('category');
        // Section title
        const title = document.createElement('div');
        title.classList.add('category-title');
        title.textContent = category.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        section.appendChild(title);
        if (uiType === 'checkbox-multi') {
          // Create a flex container for checkboxes
          const list = document.createElement('div');
          list.classList.add('tag-list');
          list.id = `list-${category}`;
          rows.forEach(row => {
            const activeValue = String(row['is-active'] || row['is_active']).toLowerCase();
            if (activeValue !== 'true') return;
            const tag = row.tag;
            const item = document.createElement('div');
            item.classList.add('tag-item');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `${category}-${tag}`;
            checkbox.value = tag;
            checkbox.checked = selectedTags.has(tag);
            checkbox.addEventListener('change', (e) => {
              if (e.target.checked) {
                selectedTags.add(tag);
              } else {
                selectedTags.delete(tag);
              }
              updateOutput();
            });
            const label = document.createElement('label');
            label.setAttribute('for', checkbox.id);
            label.setAttribute('data-tag', tag);
            // Determine initial label text
            const translationKey = `display_${selectedLanguage}`;
            let text = '';
            if (row[translationKey] && row[translationKey].trim()) {
              text = row[translationKey];
            } else if (row.display_en && row.display_en.trim()) {
              text = row.display_en;
            } else {
              text = tag;
            }
            label.textContent = text;
            item.appendChild(checkbox);
            item.appendChild(label);
            list.appendChild(item);
          });
          section.appendChild(list);
        } else if (uiType === 'dropdown-single') {
          // Create a dropdown for single selection
          const select = document.createElement('select');
          select.id = `select-${category}`;
          select.style.maxWidth = '100%';
          // Add an empty option for no selection
          const emptyOption = document.createElement('option');
          emptyOption.value = '';
          emptyOption.textContent = '--';
          select.appendChild(emptyOption);
          rows.forEach(row => {
            const activeValue = String(row['is-active'] || row['is_active']).toLowerCase();
            if (activeValue !== 'true') return;
            const tag = row.tag;
            const option = document.createElement('option');
            option.value = tag;
            // Determine initial option text
            const translationKey = `display_${selectedLanguage}`;
            let text = '';
            if (row[translationKey] && row[translationKey].trim()) {
              text = row[translationKey];
            } else if (row.display_en && row.display_en.trim()) {
              text = row.display_en;
            } else {
              text = tag;
            }
            option.textContent = text;
            // Set selected if this tag was previously chosen
            if (selectedPerCategory[category] === tag) {
              option.selected = true;
            }
            select.appendChild(option);
          });
          // Event handler for selection changes
          select.addEventListener('change', (e) => {
            const previous = selectedPerCategory[category];
            if (previous) {
              selectedTags.delete(previous);
            }
            const value = e.target.value;
            if (value) {
              selectedTags.add(value);
              selectedPerCategory[category] = value;
            } else {
              delete selectedPerCategory[category];
            }
            updateOutput();
          });
          section.appendChild(select);
        }
        container.appendChild(section);
      }
    }

    /**
     * Update the output textarea and calendar link based on selected tags.
     */
    function updateOutput() {
      const output = document.getElementById('tag-output');
      const tagsArray = Array.from(selectedTags).map(tag => `#${tag}`);
      const tagString = tagsArray.join(' ');
      output.value = tagString;
      // Update calendar link
      const calendarLink = document.getElementById('calendar-link');
      // Insert the tags into the details field after a separator line.  Use
      // Google Calendar's eventedit endpoint for better compatibility.
      let detailsParam = '';
      if (tagString) {
        detailsParam = '\n\n---\n' + tagString;
      }
      const encodedDetails = encodeURIComponent(detailsParam);
      const calendarURL = 'https://calendar.google.com/calendar/u/0/r/eventedit?details=' + encodedDetails;
      calendarLink.href = calendarURL;
    }

    /**
     * Initialize the page: load all categories, determine languages,
     * set default language and build UI.
     */
    async function init() {
      // Load each category sequentially
      const languageLists = [];
      for (const [category, gid] of Object.entries(tagCategories)) {
        const rows = await loadCategoryData(category, gid);
        categoryData[category] = rows;
        if (rows.length > 0) {
          languageLists.push(extractLanguages(rows[0]));
        }
      }
      // Compute available languages across all categories
      availableLanguages = intersectLanguages(languageLists);
      log('Available languages across sheets:', availableLanguages);
      // Determine default language based on browser settings
      const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
      if (availableLanguages.includes(browserLang)) {
        selectedLanguage = browserLang;
      } else if (availableLanguages.includes('en')) {
        selectedLanguage = 'en';
      } else if (availableLanguages.length > 0) {
        selectedLanguage = availableLanguages[0];
      }
      log('Selected language for labels:', selectedLanguage);
      buildLanguageSelector();
      buildCategoryUI();
      // Refresh labels to reflect the chosen language
      refreshCategoryLabels();
      updateOutput();
      // If no categories loaded (all arrays empty), show message
      const anyData = Object.values(categoryData).some(rows => rows && rows.length > 0);
      if (!anyData) {
        const container = document.getElementById('categories');
        container.innerHTML = '<p style="color:red;">No tag data loaded. Verify that the sheets are published and the URLs are reachable. See debug log for details.</p>';
      }
    }

    // Copy button handler
    document.getElementById('copy-btn').addEventListener('click', () => {
      const text = document.getElementById('tag-output').value;
      if (!navigator.clipboard) {
        // Fallback: select and copy
        const textarea = document.getElementById('tag-output');
        textarea.focus();
        textarea.select();
        try {
          document.execCommand('copy');
          alert('Copied to clipboard');
        } catch (err) {
          alert('Unable to copy');
        }
      } else {
        navigator.clipboard.writeText(text).then(() => {
          alert('Copied to clipboard');
        }, (err) => {
          alert('Unable to copy');
        });
      }
    });

    // Kick off initialisation when DOM is ready
    document.addEventListener('DOMContentLoaded', init);

    // Show debug log area when DEBUG is true
    document.addEventListener('DOMContentLoaded', () => {
      if (DEBUG) {
        const dbg = document.getElementById('debug-log');
        if (dbg) dbg.style.display = 'block';
      }
    });
  </script>
</body>
</html>