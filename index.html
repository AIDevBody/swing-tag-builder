<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swing Tag Builder</title>
  <!--
    This page lets event managers compose a list of hashtags for their Google
    Calendar events. It reuses the same look and feel and tag definitions as
    the Swing calendar feed builder. Tags are loaded from the CSV files under
    the resources/tags directory. A line of dashes is added above the tag list
    when copying or inserting into an event description. A button generates
    a Google Calendar event creation link prefilled with the event title,
    description, location and selected tags. All visible text is localised
    using JSON files located in resources/local/[lang]/strings.json. The page
    automatically adapts to the selected language in the dropdown.
  -->
  <style>
    :root {
      --gap: 12px;
      --pad: 14px;
      --radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    body {
      margin: 0;
      padding: 20px;
      background: #0b0f16;
      color: #eaf0ff;
    }
    a { color: #9bcbff; }
    .container {
      max-width: 960px;
      margin-left: auto;
      margin-right: auto;
    }
    header {
      margin-bottom: 22px;
    }
    .card {
      background: #121827;
      border: 1px solid #1f2a44;
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: var(--gap);
    }
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: var(--gap);
    }
    button, select, input, textarea {
      background: #1a2540;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
    }
    button:hover {
      background: #2a3f66;
      border-color: #3c548a;
    }
    /* Make inputs and textareas span the full width */
    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      resize: vertical;
    }
    .field {
      margin-bottom: var(--gap);
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: var(--gap);
    }
    .tag-group {
      margin-bottom: var(--gap);
    }
    .tag-group label {
      display: block;
      margin-bottom: 4px;
      font-weight: 600;
      color: #bcd1ff;
    }
    .selected-tags {
      margin-top: var(--gap);
    }
    .selected-tags textarea {
      height: 60px;
    }
    .title-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--gap);
    }
    .lang-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="title-bar">
        <h1 id="title">Swing Tag Builder</h1>
        <div class="lang-container">
          <label id="langLabel" for="lang">Language:</label>
          <select id="lang"></select>
        </div>
      </div>
      <p id="intro" class="muted"></p>
    </header>

    <section class="card">
      <div class="controls">
        <button id="copyTags">Copy tags</button>
        <button id="clearSelections">Clear selections</button>
      </div>
      <div class="event-fields">
        <div class="field">
          <label id="eventTitleLabel" for="eventTitle"></label>
          <input id="eventTitle" type="text" placeholder="" />
        </div>
        <div class="field">
          <label id="locationLabel" for="location"></label>
          <input id="location" type="text" placeholder="" />
        </div>
        <div class="field">
          <label id="descriptionLabel" for="description"></label>
          <textarea id="description" rows="3" placeholder=""></textarea>
        </div>
      </div>
      <div id="tagSelectors" class="row"></div>
      <div class="selected-tags">
        <label id="selectedTagsLabel" for="tagsOutput"></label>
        <textarea id="tagsOutput" readonly></textarea>
      </div>
      <div class="event-create" style="margin-top: var(--gap);">
        <button id="createEvent">Create event</button>
      </div>
    </section>
  </div>

  <script>
  // Global state for languages, tags and selections
  let languages = ['en', 'de'];
  let currentLang = 'en';
  let strings = {};
  // Holds UI info (ui_type, display names) per tag type
  const typeSettings = {};
  // Holds arrays of tag objects per type
  const tagsByType = {};
  // Holds selected tag(s) per type. For checkbox-multi types this is a Set, for dropdown-single it's a string
  const state = {};
  // Constructed tag string that will be copied or inserted into events
  let tagsString = '';

  // Fetch localisation strings for a given language code
  async function loadStrings(lang) {
    try {
      const res = await fetch(`resources/local/${lang}/strings.json`, {cache: 'no-store'});
      if (!res.ok) throw new Error('Failed to load strings');
      strings = await res.json();
    } catch (err) {
      console.warn('Could not load localisation for', lang, err);
      if (lang !== 'en') {
        // fallback to English
        await loadStrings('en');
      }
    }
  }

  // Load tag UI definitions (typeSettings) from tags_ui.csv
  async function loadTypeSettings() {
    try {
      const res = await fetch('resources/tags/ui/tags_ui.csv', {cache: 'no-store'});
      if (!res.ok) throw new Error('Failed to load tag UI definitions');
      const text = await res.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return;
      const header = lines[0].split(',');
      const idxType = header.indexOf('tag_type');
      const idxUi = header.indexOf('ui_type');
      const langCols = {};
      header.forEach((h, i) => {
        const m = h.match(/^display_(.+)$/);
        if (m) langCols[m[1]] = i;
      });
      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(',');
        const type = parts[idxType];
        if (!type) continue;
        const uiType = parts[idxUi] || 'checkbox-multi';
        const obj = { ui_type: uiType, display: {} };
        for (const lang in langCols) {
          obj.display[lang] = parts[langCols[lang]] || type;
        }
        typeSettings[type] = obj;
      }
    } catch (err) {
      console.error(err);
    }
  }

  // Load all tag data from the CSV files
  async function loadTags() {
    // Determine which types to load based on typeSettings or fallback list
    const defaultTypes = [
      'location','dance_type','event_type','level','role','music_speed','music_source','language','venue_type','registration','price_type','age_policy','footwear'
    ];
    const types = Object.keys(typeSettings);
    const toLoad = types.length ? types : defaultTypes;
    const langSet = new Set(languages);
    for (const type of toLoad) {
      try {
        const res = await fetch(`resources/tags/all/${type}.csv`, {cache: 'no-store'});
        if (!res.ok) {
          console.warn('Could not load tags for', type);
          continue;
        }
        const csvText = await res.text();
        const lines = csvText.trim().split(/\r?\n/);
        if (lines.length === 0) continue;
        const header = lines[0].split(',');
        const idxTag = header.indexOf('tag');
        const idxActive = header.findIndex(h => h.toLowerCase() === 'is-active');
        // detect language columns display_xx
        const displayCols = {};
        header.forEach((h, i) => {
          const m = h.match(/^display_(.+)$/);
          if (m) {
            displayCols[m[1]] = i;
            langSet.add(m[1]);
          }
        });
        const items = [];
        for (let i = 1; i < lines.length; i++) {
          const parts = lines[i].split(',');
          const tagVal = parts[idxTag];
          if (!tagVal) continue;
          const isActive = idxActive >= 0 ? (parts[idxActive] || '').toLowerCase() === 'true' : true;
          if (!isActive) continue;
          const obj = { tag: tagVal };
          for (const code in displayCols) {
            obj[`display_${code}`] = parts[displayCols[code]] || tagVal;
          }
          items.push(obj);
        }
        tagsByType[type] = items;
      } catch (err) {
        console.warn('Error loading tag CSV for', type, err);
      }
    }
    // Update global languages from discovered set
    languages = Array.from(langSet);
  }

  // Populate the language select dropdown
  function initLanguages() {
    const sel = document.getElementById('lang');
    sel.innerHTML = '';
    languages.forEach(code => {
      const opt = document.createElement('option');
      opt.value = code;
      opt.textContent = code;
      sel.appendChild(opt);
    });
    sel.value = currentLang;
    sel.addEventListener('change', async () => {
      currentLang = sel.value;
      await loadStrings(currentLang);
      updateStaticText();
      renderTagSelectors();
      updateTagsOutput();
    });
  }

  // Update static text labels based on the loaded strings
  function updateStaticText() {
    document.getElementById('title').textContent = strings.title || 'Swing Tag Builder';
    document.getElementById('langLabel').textContent = strings.language_label || 'Language:';
    document.getElementById('eventTitleLabel').textContent = strings.event_title_label || 'Event title';
    document.getElementById('eventTitle').placeholder = strings.event_title_placeholder || '';
    document.getElementById('locationLabel').textContent = strings.location_label || 'Location';
    document.getElementById('location').placeholder = strings.location_placeholder || '';
    document.getElementById('descriptionLabel').textContent = strings.description_label || 'Description';
    document.getElementById('description').placeholder = strings.description_placeholder || '';
    document.getElementById('selectedTagsLabel').textContent = strings.selected_tags_label || 'Selected Tags';
    document.getElementById('copyTags').textContent = strings.copy_tags_button || 'Copy tags';
    document.getElementById('clearSelections').textContent = strings.clear_selections_button || 'Clear selections';
    document.getElementById('createEvent').textContent = strings.create_event_button || 'Create event';
  }

  // Render tag selectors for each type
  function renderTagSelectors() {
    const container = document.getElementById('tagSelectors');
    container.innerHTML = '';
    const types = Object.keys(tagsByType);
    types.sort();
    types.forEach(type => {
      const items = tagsByType[type];
      if (!items || items.length === 0) return;
      const settings = typeSettings[type] || { ui_type: 'checkbox-multi', display: {} };
      const group = document.createElement('div');
      group.className = 'tag-group';
      const label = document.createElement('label');
      const langName = settings.display[currentLang] || settings.display['en'] || type;
      label.textContent = langName;
      group.appendChild(label);
      if (settings.ui_type === 'dropdown-single') {
        const sel = document.createElement('select');
        // Add placeholder option
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = strings.select_placeholder || '— select —';
        sel.appendChild(placeholder);
        items.forEach(item => {
          const opt = document.createElement('option');
          opt.value = item.tag;
          opt.textContent = item[`display_${currentLang}`] || item[`display_en`] || item.tag;
          sel.appendChild(opt);
        });
        // Set current value if any
        sel.value = state[type] || '';
        sel.addEventListener('change', () => {
          state[type] = sel.value;
          updateTagsOutput();
        });
        group.appendChild(sel);
      } else {
        // checkbox-multi
        if (!state[type] || !(state[type] instanceof Set)) state[type] = new Set();
        items.forEach(item => {
          const wrapper = document.createElement('label');
          wrapper.style.display = 'block';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = item.tag;
          input.checked = state[type].has(item.tag);
          input.addEventListener('change', () => {
            if (input.checked) {
              state[type].add(item.tag);
            } else {
              state[type].delete(item.tag);
            }
            updateTagsOutput();
          });
          wrapper.appendChild(input);
          const span = document.createElement('span');
          span.textContent = ' ' + (item[`display_${currentLang}`] || item[`display_en`] || item.tag);
          wrapper.appendChild(span);
          group.appendChild(wrapper);
        });
      }
      container.appendChild(group);
    });
  }

  // Build the tag string and update the output textarea
  function updateTagsOutput() {
    const tags = [];
    for (const type in state) {
      const val = state[type];
      if (!val) continue;
      if (val instanceof Set) {
        val.forEach(v => {
          tags.push('#' + v);
        });
      } else if (typeof val === 'string' && val !== '') {
        tags.push('#' + val);
      }
    }
    if (tags.length > 0) {
      // Create a separator line. Use three dashes to visually separate tags
      const line = '---';
      const tagLine = tags.map(t => ' ' + t).join('');
      tagsString = `${line}\n${tagLine}`;
    } else {
      tagsString = '';
    }
    document.getElementById('tagsOutput').value = tagsString;
  }

  // Copy the current tag string to clipboard
  async function copyTagsToClipboard() {
    const output = document.getElementById('tagsOutput');
    output.focus();
    output.select();
    try {
      await navigator.clipboard.writeText(output.value);
      const btn = document.getElementById('copyTags');
      const original = btn.textContent;
      btn.textContent = strings.copy_success || 'Copied!';
      setTimeout(() => { btn.textContent = original; }, 2000);
    } catch (err) {
      // fallback: instruct user to copy manually
      alert(strings.copy_error || 'Press Ctrl/Cmd+C to copy.');
    }
  }

  // Clear all selections and reset state
  function clearAllSelections() {
    for (const type in state) {
      if (state[type] instanceof Set) {
        state[type].clear();
      } else {
        state[type] = '';
      }
    }
    document.getElementById('eventTitle').value = '';
    document.getElementById('location').value = '';
    document.getElementById('description').value = '';
    renderTagSelectors();
    updateTagsOutput();
  }

  // Build a Google Calendar event creation link and open it
  function createEvent() {
    const title = document.getElementById('eventTitle').value.trim();
    const location = document.getElementById('location').value.trim();
    let description = document.getElementById('description').value.trim();
    // Append tags to the description if any
    if (tagsString) {
      if (description) {
        description += '\n\n' + tagsString;
      } else {
        description = tagsString;
      }
    }
    // Build base URL
    let url = 'https://calendar.google.com/calendar/render?action=TEMPLATE';
    if (title) url += '&text=' + encodeURIComponent(title);
    if (description) url += '&details=' + encodeURIComponent(description);
    if (location) url += '&location=' + encodeURIComponent(location);
    // Open in new tab
    window.open(url, '_blank');
  }

  // Attach event handlers
  function attachHandlers() {
    document.getElementById('copyTags').addEventListener('click', copyTagsToClipboard);
    document.getElementById('clearSelections').addEventListener('click', clearAllSelections);
    document.getElementById('createEvent').addEventListener('click', createEvent);
  }

  // Initialise the page
  (async () => {
    await loadTypeSettings();
    await loadTags();
    await loadStrings(currentLang);
    initLanguages();
    updateStaticText();
    renderTagSelectors();
    updateTagsOutput();
    attachHandlers();
  })();
  </script>
</body>
</html>